{
  "nodes": [
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8246ff18-5201-496a-8e4b-89ab6a7cf42c",
              "name": "segments",
              "value": "={{ $json.segments.map(item => (\n  {\n    \"images\": item.images,\n    \"textOnScreen\": `${item.textOnScreen}`,\n    \"durationOnScreen\": item.durationOnScreen || 5,\n    \"durationMode\": item.durationMode || 'fixed'\n  }\n))}}",
              "type": "array"
            },
            {
              "id": "1471f5a1-6e69-4d86-8047-8c84a50803bf",
              "name": "audioInBase64",
              "value": "={{ $json.audioInBase64 }}",
              "type": "string"
            },
            {
              "id": "717abae9-c226-4b91-b45e-f1c027386678",
              "name": "transcript",
              "value": "={{ $json.transcript }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1500,
        -340
      ],
      "id": "c4f14412-9f5d-4124-a4c6-0e5445ea2048",
      "name": "1. Prepare Data"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node: Generate FFmpeg Command\n// Helper functions adapted from server.js\n\n// Function to format time for ASS subtitles\nfunction formatAssTime(seconds) {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = Math.floor(seconds % 60);\n    const centiseconds = Math.floor((seconds * 100) % 100);\n    return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;\n}\n\n// Function to generate ASS subtitle content\nfunction generateAssSubtitles(transcript, style = {}) {\n    const defaultStyle = {\n        Name: 'Default', Fontname: 'Arial', Fontsize: '28', PrimaryColour: '&H00FFFFFF', \n        SecondaryColour: '&H000000FF', OutlineColour: '&H00000000', BackColour: '&H00000000',\n        Bold: '-1', Italic: '0', Underline: '0', StrikeOut: '0', ScaleX: '100', ScaleY: '100',\n        Spacing: '0', Angle: '0', BorderStyle: '1', Outline: '2', Shadow: '1',\n        Alignment: '2', MarginL: '10', MarginR: '10', MarginV: '10', Encoding: '1'\n    };\n    const mergedStyle = { ...defaultStyle, ...style };\n\n    let assContent = '[Script Info]\\nTitle: Generated Subtitles\\nScriptType: v4.00+\\nWrapStyle: 0\\nPlayResX: 1920\\nPlayResY: 1080\\nScaledBorderAndShadow: yes\\n\\n';\n    assContent += '[V4+ Styles]\\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\\n';\n    assContent += `Style: ${mergedStyle.Name},${mergedStyle.Fontname},${mergedStyle.Fontsize},${mergedStyle.PrimaryColour},${mergedStyle.SecondaryColour},${mergedStyle.OutlineColour},${mergedStyle.BackColour},${mergedStyle.Bold},${mergedStyle.Italic},${mergedStyle.Underline},${mergedStyle.StrikeOut},${mergedStyle.ScaleX},${mergedStyle.ScaleY},${mergedStyle.Spacing},${mergedStyle.Angle},${mergedStyle.BorderStyle},${mergedStyle.Outline},${mergedStyle.Shadow},${mergedStyle.Alignment},${mergedStyle.MarginL},${mergedStyle.MarginR},${mergedStyle.MarginV},${mergedStyle.Encoding}\\n\\n`;\n    assContent += '[Events]\\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\\n';\n\n    transcript.forEach(word => {\n        const start = formatAssTime(word.start);\n        const end = formatAssTime(word.end);\n        assContent += `Dialogue: 0,${start},${end},${mergedStyle.Name},,0,0,0,,{\\\\an5}${word.word}\\\\N\\n`; \n    });\n\n    return assContent;\n}\n\n// --- Main Logic --- \nconst newItem = {};\nconst inputData = $input.item.json;\nconst fs = require('fs').promises;\nconst path = require('path');\nconst os = require('os');\nconst crypto = require('crypto');\n\n// Create a unique temporary directory for this execution\nconst requestId = crypto.randomUUID();\nconst tempDir = path.join(os.tmpdir(), 'n8n_ffmpeg_' + requestId);\n\nnewItem.json = { ...inputData }; // Copy input data\n\ntry {\n  await fs.mkdir(tempDir, { recursive: true });\n  console.log(`Created temp directory: ${tempDir}`);\n\n  // --- 1. Decode Audio --- \n  const audioFilePath = path.join(tempDir, 'audio.mp3');\n  const audioBuffer = Buffer.from(inputData.audioInBase64, 'base64');\n  await fs.writeFile(audioFilePath, audioBuffer);\n  console.log(`Decoded audio saved to: ${audioFilePath}`);\n  newItem.json.audioFilePath = audioFilePath; // Store path for ffmpeg\n\n  // --- 2. Prepare Image Paths --- \n  let imagePaths = [];\n  if (inputData.imageLocalPaths && Array.isArray(inputData.imageLocalPaths) && inputData.imageLocalPaths.length === inputData.segments.length) {\n      imagePaths = inputData.imageLocalPaths;\n      console.log('Using provided imageLocalPaths.');\n  } else {\n      console.warn('imageLocalPaths not provided or invalid. Attempting to use URLs directly.');\n      imagePaths = inputData.segments.map((seg, idx) => {\n          if (!seg.images || !seg.images[0] || !seg.images[0].url) {\n              throw new Error(`Segment ${idx} is missing a valid image URL.`);\n          }\n          return seg.images[0].url;\n      });\n  }\n  newItem.json.imagePathsUsed = imagePaths; // Store for debugging/info\n\n  // --- 3. Generate Subtitles --- \n  const subtitlesFilePath = path.join(tempDir, 'subtitles.ass');\n  const subtitleStyle = { \n      Fontsize: '36',\n      PrimaryColour: '&H00FFFFFF', \n      OutlineColour: '&HFF000000', \n      Outline: '2', \n      Shadow: '1', \n      Alignment: '2' \n  };\n  const assContent = generateAssSubtitles(inputData.transcript, subtitleStyle);\n  await fs.writeFile(subtitlesFilePath, assContent);\n  console.log(`Generated ASS subtitles saved to: ${subtitlesFilePath}`);\n  newItem.json.subtitlesFilePath = subtitlesFilePath;\n\n  // --- 4. Construct FFmpeg Command --- \n  const outputVideoPath = path.join(tempDir, 'output.mp4');\n  const segments = inputData.segments;\n  const totalDuration = inputData.transcript[inputData.transcript.length - 1]?.end || segments.reduce((sum, s) => sum + s.durationOnScreen, 0); \n\n  let command = 'ffmpeg';\n  let filterComplex = '';\n  let inputArgs = [];\n  let segmentOutputs = [];\n  let concatInputs = '';\n\n  // Add image inputs and scale/pad them\n  segments.forEach((segment, index) => {\n      const imagePath = imagePaths[index]; \n      inputArgs.push('-loop', '1', '-t', segment.durationOnScreen, '-i', imagePath);\n      filterComplex += `[${index}:v]scale=1920:1080:force_original_aspect_ratio=decrease,pad=1920:1080:(ow-iw)/2:(oh-ih)/2:color=black,setsar=1[img${index}]; `;\n      segmentOutputs.push(`[img${index}]`);\n  });\n\n  // Concatenate scaled images\n  concatInputs = segmentOutputs.join('');\n  filterComplex += `${concatInputs}concat=n=${segments.length}:v=1:a=0[concatenated_video]; `;\n\n  // Add audio input\n  inputArgs.push('-i', audioFilePath);\n  const audioInputIndex = segments.length; \n\n  // Overlay subtitles \n  // Escape colon for FFmpeg ass filter\n  const escapedSubtitlesPath = subtitlesFilePath.replace(/:/g, \'\\\\\\\\:\');\n  filterComplex += `[concatenated_video]ass=filename=\'${escapedSubtitlesPath}\'[video_with_subs]`;\n\n  // Final command arguments\n  command += ` ${inputArgs.join(' ')}`; \n  command += ` -filter_complex \"${filterComplex}\"`; \n  command += ` -map \"[video_with_subs]\"`; \n  command += ` -map ${audioInputIndex}:a`; \n  command += ` -c:v libx264 -preset veryfast -crf 23 -c:a aac -b:a 192k -shortest`; \n  command += ` -y ${outputVideoPath}`; \n\n  console.log(\"Generated FFmpeg command:\", command);\n  newItem.json.ffmpegCommand = command;\n  newItem.json.outputVideoPath = outputVideoPath;\n  newItem.json.tempDir = tempDir; \n\n} catch (error) {\n  console.error(\"Error in Code node:\", error);\n  throw new Error(`Code node failed: ${error.message}`);\n}\n\nreturn newItem;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1720,
        -340
      ],
      "id": "2200fdb3-0d72-4e3b-adaf-eb82113daa24",
      "name": "2. Generate FFmpeg Cmd"
    },
    {
      "parameters": {
        "command": "={{ $json.ffmpegCommand }}",
        "options": {
          "shell": true
        }
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        1940,
        -340
      ],
      "id": "65ecd857-823f-42fd-b38e-1ee8ab32c6c4",
      "name": "3. Execute FFmpeg"
    }
  ],
  "connections": {
    "1. Prepare Data": {
      "main": [
        [
          {
            "node": "2. Generate FFmpeg Cmd",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Generate FFmpeg Cmd": {
      "main": [
        [
          {
            "node": "3. Execute FFmpeg",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "6d0156efecc697043cecd29b6df583460758b37b24b6eeda34ea6c7f9ba03e66"
  }
} 